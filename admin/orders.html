<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Team Store Admin — Orders</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background:#f6f7fb; color:#111; }
    header { padding: 16px 18px; background:#111; color:#fff; display:flex; align-items:center; gap:12px; }
    header h1 { font-size: 16px; margin:0; font-weight:700; }
    header .muted { opacity:.8; font-size: 12px; }
    main { display:grid; grid-template-columns: 1.1fr .9fr; gap: 14px; padding: 14px; }
    @media (max-width: 980px){ main{ grid-template-columns: 1fr; } }
    .card { background:#fff; border-radius: 12px; box-shadow: 0 1px 10px rgba(0,0,0,.06); overflow:hidden; }
    .card .hd { padding: 12px 14px; border-bottom: 1px solid #eee; display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .card .bd { padding: 12px 14px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    input[type="text"]{ padding: 9px 10px; border:1px solid #ddd; border-radius: 10px; width: 260px; max-width: 100%; }
    button { border:0; background:#111; color:#fff; padding: 9px 12px; border-radius:10px; font-weight:700; cursor:pointer; }
    button.secondary { background:#e9eaef; color:#111; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .chips { display:flex; gap:8px; flex-wrap:wrap; }
    .chip { border:1px solid #ddd; background:#fff; padding:7px 10px; border-radius:999px; font-size:12px; cursor:pointer; user-select:none; }
    .chip.on { background:#111; color:#fff; border-color:#111; }
    table { width:100%; border-collapse: collapse; }
    th, td { padding: 10px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; vertical-align: top; }
    th { text-align:left; font-size: 12px; color:#444; }
    tr.clickable { cursor:pointer; }
    tr.clickable:hover { background:#fafafa; }
    .badge { display:inline-block; padding:3px 8px; border-radius:999px; font-size:11px; background:#eef0ff; color:#2a2f77; }
    .status { display:flex; gap:10px; flex-wrap:wrap; }
    .status label { display:flex; gap:6px; align-items:center; font-size: 13px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .muted { color:#666; font-size: 12px; }
    .items li { margin: 6px 0; }
    .divider { height:1px; background:#eee; margin: 10px 0; }
    .print-area { display:none; }
    @media print {
      header, .no-print { display:none !important; }
      main { display:block; padding:0; }
      .card { box-shadow:none; border-radius:0; }
      .print-area { display:block; }
    }
  </style>
</head>
<body>
<header>
  <h1>Admin — Orders</h1>
  <div class="muted">Default: delivered hidden • Click an order for details</div>
  <div style="margin-bottom:12px;">
    <a href="products.html">→ Manage Products</a>
  </div>
</header>

<main>
  <!-- LEFT: Orders List -->
  <section class="card">
    <div class="hd no-print">
      <div class="row">
        <input id="q" type="text" placeholder="Search order id or name…" />
        <input id="batchQ" type="text" placeholder="Filter by batch (VB-20260211-01)" style="width:220px;" />
        <button class="secondary" id="refreshBtn">Refresh</button>
    </div>
      <div class="muted" id="countLabel"></div>
    </div>
    <div class="bd no-print">
      <div class="chips" style="margin-bottom:10px;">
        <div class="chip on" id="chipHideDelivered">Hide delivered</div>
        <div class="chip" id="chipUnpaid">Unpaid</div>
        <div class="chip" id="chipNotOrdered">Not ordered</div>
        <div class="chip" id="chipNotReceived">Not received</div>
        <div class="chip" id="chipShowDelivered">Show delivered only</div>
        <div class="row" style="margin: 10px 0;">
            <button id="createBatchBtn" disabled>Create Batch</button>
            <button id="printBatchBtn" class="secondary" disabled>Print Batch</button>
            <span id="batchHint" class="muted"></span>
        </div>

      </div>

      <table>
        <thead>
          <tr>
            <th>Order</th>
            <th>Name</th>
            <th>Total</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="ordersTbody">
          <tr><td colspan="4" class="muted">Loading…</td></tr>
        </tbody>
      </table>
    </div>
  </section>

  <!-- RIGHT: Detail -->
  <aside class="card" id="detailCard">
    <div class="hd">
      <div>
        <div style="font-weight:800;" id="detailTitle">Select an order</div>
        <div class="muted" id="detailSub"></div>
      </div>
      <div class="row no-print">
        <button class="secondary" id="printBtn" disabled>Print checklist</button>
      </div>
    </div>
    <div class="bd" id="detailBody">
      <div class="muted">Click an order on the left to see item details and update statuses.</div>
    </div>

    <!-- Print-only block -->
    <div class="bd print-area" id="printArea"></div>
  </aside>
</main>

<script type="module">
  import { createClient } from "https://esm.sh/@supabase/supabase-js@2.29.0";

  // ✅ Fill these in
  const SUPABASE_URL = "https://oaxwmguhucxaucpyofil.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_jD2x3piN7xnCIjca94gYFA_zzkbjS7T";


  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);



  async function requireAdmin() {
    const { data: { user } } = await supabase.auth.getUser();

    // Not logged in → send to products page (which has login UI)
    if (!user) {
      const next = encodeURIComponent("/admin/orders.html");
      window.location.href = `/admin/products.html?next=${next}`;
      return false;
    }

    // Logged in but not an admin → block
    const { data, error } = await supabase
      .from("admin_users")
      .select("user_id")
      .eq("user_id", user.id)
      .single();

    if (error || !data) {
      alert("Not authorized.");
      await supabase.auth.signOut();
      const next = encodeURIComponent("/admin/orders.html");
      window.location.href = `/admin/products.html?next=${next}`;
      return false;
    }

    return true;
  }
  const els = {
    q: document.getElementById("q"),
    batchQ: document.getElementById("batchQ"),
    refreshBtn: document.getElementById("refreshBtn"),
    tbody: document.getElementById("ordersTbody"),
    countLabel: document.getElementById("countLabel"),
    // chips
    chipHideDelivered: document.getElementById("chipHideDelivered"),
    chipUnpaid: document.getElementById("chipUnpaid"),
    chipNotOrdered: document.getElementById("chipNotOrdered"),
    chipNotReceived: document.getElementById("chipNotReceived"),
    chipShowDelivered: document.getElementById("chipShowDelivered"),
    // detail
    detailTitle: document.getElementById("detailTitle"),
    detailSub: document.getElementById("detailSub"),
    detailBody: document.getElementById("detailBody"),
    printBtn: document.getElementById("printBtn"),
    printArea: document.getElementById("printArea"),
    createBatchBtn: document.getElementById("createBatchBtn"),
    printBatchBtn: document.getElementById("printBatchBtn"),
    batchHint: document.getElementById("batchHint"),

  };

    function isTrue(v){
        return v === true || v === "true" || v === 1 || v === "1";
        }

        function hasText(v){
        return v != null && String(v).trim() !== "";
        }

  const state = {
    ordersRaw: [],
    groups: [],
    selectedOrderId: null,
    filters: {
      hideDelivered: true,
      unpaid: false,
      notOrdered: false,
      notReceived: false,
      showDeliveredOnly: false,
      q: "",
      batchNumber: "",
    },
  };

  const { data: { session } } = await supabase.auth.getSession();
  const token = session?.access_token;

  function getVisibleGroups(){
  return state.groups.filter(passesFilters);
    }

  function money(n){ return (Math.round(n*100)/100).toFixed(2); }

  function toggleChip(el, on){
    el.classList.toggle("on", !!on);
  }

  function applyCascade(current, key, value){
    // current: {paid, ordered, received, delivered}
    // key: toggled checkbox
    const s = { ...current };

    if (value === true){
      if (key === "paid") s.paid = true;
      if (key === "ordered"){ s.ordered = true; s.paid = true; }
      if (key === "received"){ s.received = true; s.ordered = true; s.paid = true; }
      if (key === "delivered"){ s.delivered = true; s.received = true; s.ordered = true; s.paid = true; }
    } else {
      if (key === "paid"){ s.paid = false; s.ordered = false; s.received = false; s.delivered = false; }
      if (key === "ordered"){ s.ordered = false; s.received = false; s.delivered = false; }
      if (key === "received"){ s.received = false; s.delivered = false; }
      if (key === "delivered"){ s.delivered = false; }
    }
    return s;
  }
    function updateBatchButtons(){
    const visible = getVisibleGroups();

    const createEligible = visible.filter(g =>
        g.status?.paid === true &&
        g.status?.ordered === false &&
        !hasText(g.vendor_batch)
    );

    const printableBatches = new Set(
        visible
        .filter(g => g.status?.paid === true && g.status?.ordered === true && hasText(g.vendor_batch))
        .map(g => String(g.vendor_batch).trim())
    );

    els.createBatchBtn.disabled = createEligible.length === 0;
    els.printBatchBtn.disabled = printableBatches.size === 0;

    // optional hint text
    const msgs = [];
    if (createEligible.length) msgs.push(`${createEligible.length} order(s) eligible to batch`);
    if (printableBatches.size) msgs.push(`${printableBatches.size} batch(es) printable`);
    els.batchHint.textContent = msgs.join(" • ");
    }



  function groupOrders(rows){
    const map = new Map();
    for (const r of rows){
      const id = r.order_id;
      if (!map.has(id)) map.set(id, []);
      map.get(id).push(r);
    }
    const groups = [];
    for (const [order_id, items] of map.entries()){
      const first = items[0];
      const totalNum = items.reduce((sum, x) => sum + Number(x.unit_price || 0), 0);
        const toBool = (v) => v === true || v === "true" || v === 1 || v === "1";

        const status = {
        paid: toBool(first.paid),
        ordered: toBool(first.ordered),
        received: toBool(first.received),
        delivered: toBool(first.delivered),
        };

      groups.push({
        order_id,
        parent_name: first.parent_name || "",
        email: first.email || "",
        total: money(totalNum),
        status,
        items,
        created_at: first.created_at || null,
        vendor_batch: items.some(x => x.vendor_batch) ? (items.find(x=>x.vendor_batch)?.vendor_batch || null) : null,

      });
    }
    // newest first if created_at exists, else lexical order_id desc
    groups.sort((a,b)=>{
      if (a.created_at && b.created_at) return b.created_at.localeCompare(a.created_at);
      return b.order_id.localeCompare(a.order_id);
    });
    return groups;
  }

  function passesFilters(g){
    const f = state.filters;
      // if a batch filter is set, only show groups in that batch (case-insensitive, partial match)
    if (f.batchNumber) {
        if (!g.vendor_batch) return false;
        if (!String(g.vendor_batch).toLowerCase().includes(f.batchNumber.toLowerCase())) return false;
    }

    // Delivered visibility
    if (f.showDeliveredOnly) {
        if (!g.status.delivered) return false;
    } else if (f.hideDelivered) {
        if (g.status.delivered) return false;
    }

    // Cascading workflow filters (mutually compatible, but better as "stage" filters)
    if (f.unpaid) {
        if (g.status.paid) return false;                 // unpaid only
    }

    if (f.notOrdered) {
        if (!g.status.paid) return false;                // must be paid
        if (g.status.ordered) return false;              // not ordered
    }

    if (f.notReceived) {
        if (!g.status.paid) return false;                // must be paid
        if (!g.status.ordered) return false;             // must be ordered
        if (g.status.received) return false;             // not received
    }

    const q = (f.q || "").trim().toLowerCase();
    if (q){
        const hay = `${g.order_id} ${g.parent_name}`.toLowerCase();
        if (!hay.includes(q)) return false;
    }

    return true;
    }


  function statusBadges(s){
    const parts = [];
    if (s.paid) parts.push(`<span class="badge">paid</span>`);
    if (s.ordered) parts.push(`<span class="badge">ordered</span>`);
    if (s.received) parts.push(`<span class="badge">received</span>`);
    if (s.delivered) parts.push(`<span class="badge">delivered</span>`);
    if (!parts.length) parts.push(`<span class="badge">new</span>`);
    return parts.join(" ");
  }

  function renderList(){
    const filtered = state.groups.filter(passesFilters);
    els.countLabel.textContent = `${filtered.length} order(s) shown`;

    if (!filtered.length){
        els.tbody.innerHTML = `<tr><td colspan="4" class="muted">No orders match filters.</td></tr>`;
        updateBatchButtons(); // <-- ADD THIS
        return;
    }

    els.tbody.innerHTML = filtered.map(g => `
      <tr class="clickable" data-order-id="${g.order_id}">
        <td class="mono">${g.order_id}</td>
        <td>${escapeHtml(g.parent_name || "")}</td>
        <td>$${g.total}</td>
        <td>${statusBadges(g.status)}</td>
      </tr>
    `).join("");

    els.tbody.querySelectorAll("tr[data-order-id]").forEach(tr=>{
      tr.addEventListener("click", ()=> selectOrder(tr.getAttribute("data-order-id")));
    });
    // end of renderList()
    updateBatchButtons();

  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, (c)=>({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  async function selectOrder(orderId){
    state.selectedOrderId = orderId;
    const g = state.groups.find(x=>x.order_id === orderId);
    if (!g) return;

    els.detailTitle.textContent = `Order ${g.order_id}`;
    els.detailSub.textContent = `${g.parent_name} • Total $${g.total}` + (g.vendor_batch ? ` • Batch ${g.vendor_batch}` : "");
    els.printBtn.disabled = false;

    const itemLines = g.items.map(r=>{
      const nm = r.custom_text ? `Name: ${r.custom_text}` : "";
      const num = r.jersey_number ? `#${r.jersey_number}` : "";
      const extra = [nm, num].filter(Boolean).join(" • ");
      return `<li>
        <b>${escapeHtml(r.item)}</b> — ${escapeHtml(r.size || "")}
        ${extra ? `<span class="muted">(${escapeHtml(extra)})</span>` : ""}
        <span class="muted"> — $${money(Number(r.unit_price || 0))}</span>
      </li>`;
    }).join("");

    const s = g.status;

    els.detailBody.innerHTML = `
      <div class="status no-print">
        ${statusToggle("paid", s.paid)}
        ${statusToggle("ordered", s.ordered)}
        ${statusToggle("received", s.received)}
        ${statusToggle("delivered", s.delivered)}
      </div>

      <div class="divider no-print"></div>

      <div class="row no-print">
        <span class="muted">Tip: Delivered auto-sets Received/Ordered/Paid.</span>
      </div>

      <div class="divider"></div>

      <div><b>Items</b></div>
      <ul class="items">${itemLines}</ul>
    `;

    // print template
    els.printArea.innerHTML = `
      <div style="padding:12px 0;">
        <div style="font-size:18px;font-weight:800;">Order Checklist</div>
        <div style="margin:6px 0 10px 0;" class="mono">${escapeHtml(g.order_id)}</div>
        <div style="margin-bottom:10px;">${escapeHtml(g.parent_name)} — Total $${g.total}</div>
        <hr />
        <ul style="list-style:none; padding-left:0;">
          ${g.items.map(r=>{
            const nm = r.custom_text ? `Name: ${r.custom_text}` : "";
            const num = r.jersey_number ? `#${r.jersey_number}` : "";
            const extra = [nm, num].filter(Boolean).join(" • ");
            return `<li style="margin:10px 0;">
              <span style="display:inline-block; width:18px; height:18px; border:1px solid #000; margin-right:10px; vertical-align:middle;"></span>
              <span><b>${escapeHtml(r.item)}</b> — ${escapeHtml(r.size || "")} ${extra ? `(${escapeHtml(extra)})` : ""}</span>
            </li>`;
          }).join("")}
        </ul>
      </div>
    `;

    // wire toggles
    ["paid","ordered","received","delivered"].forEach(key=>{
    const cb = document.getElementById(`cb-${key}`);
    cb?.addEventListener("change", async (e)=>{
        const checked = e.target.checked;

        // 1) Cascade locally so multiple boxes appear checked immediately
        const desired = applyCascade(g.status, key, checked);
        g.status = desired;

        // 2) ✅ Only send the one field the user actually toggled
        await pushStatusUpdate(orderId, { [key]: checked });

        // 3) Re-render
        renderList();
        selectOrder(orderId);
    });
    });

  }

    function statusToggle(key, value){
        return `
        <label>
            <input type="checkbox" id="cb-${key}" ${value ? "checked" : ""} />
            <span style="text-transform:capitalize;">${key}</span>
        </label>
        `;
    }

    async function pushStatusUpdate(orderId, patch){
    // get currently-signed-in user's JWT (fresh each call)
      const { data: { session } } = await supabase.auth.getSession();
      const token = session?.access_token;
      if (!token) {
        alert("Not authenticated — please sign in.");
        // reload to show sign-in UI if needed
        await loadOrders();
        return;
      }

      const resp = await fetch(`${SUPABASE_URL}/functions/v1/update-order-status`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
        body: JSON.stringify({
          order_id: orderId,
          ...patch, // e.g. { delivered: true }
        }),
      });

      if (!resp.ok){
        const t = await resp.text().catch(()=> "");
        alert("Status update failed: " + t);
        await loadOrders();
      }
    }
    async function printBatch(vendor_batch){
        const { data, error } = await supabase
            .from("orders")
            .select("order_id,parent_name,item,size,custom_text,jersey_number,unit_price,created_at,vendor_batch")
            .eq("vendor_batch", vendor_batch)
            .order("created_at", { ascending: true });

        if (error){
            alert("Failed loading batch for print: " + error.message);
            return;
        }

        // reuse your existing print rendering by faking the function result shape
        return { batch_id: vendor_batch, items: data || [] };
        }
    function toBool(v){
    return v === true || v === "true" || v === 1 || v === "1";
    }



  async function loadOrders(){
    els.tbody.innerHTML = `<tr><td colspan="4" class="muted">Loading…</td></tr>`;

    // Pull minimal columns needed for list + detail
    const { data, error } = await supabase
      .from("orders")
      .select("order_id,parent_name,email,item,size,custom_text,jersey_number,unit_price,paid,ordered,received,delivered,created_at,vendor_batch")
      .order("created_at", { ascending: false });

    if (error){
      els.tbody.innerHTML = `<tr><td colspan="4" class="muted">Error loading orders: ${escapeHtml(error.message)}</td></tr>`;
      return;
    }

    state.ordersRaw = data || [];
    state.groups = groupOrders(state.ordersRaw);
    renderList();
    updateBatchButtons();

    // keep selection if possible
    if (state.selectedOrderId){
      selectOrder(state.selectedOrderId);
    }


  }

  // chips
  els.chipHideDelivered.addEventListener("click", ()=>{
    state.filters.hideDelivered = !state.filters.hideDelivered;
    if (state.filters.hideDelivered) state.filters.showDeliveredOnly = false;
    toggleChip(els.chipHideDelivered, state.filters.hideDelivered);
    toggleChip(els.chipShowDelivered, state.filters.showDeliveredOnly);
    renderList();
  });

  els.chipShowDelivered.addEventListener("click", ()=>{
    state.filters.showDeliveredOnly = !state.filters.showDeliveredOnly;
    if (state.filters.showDeliveredOnly) state.filters.hideDelivered = false;
    toggleChip(els.chipShowDelivered, state.filters.showDeliveredOnly);
    toggleChip(els.chipHideDelivered, state.filters.hideDelivered);
    renderList();
  });

    function setStage(stage){
        state.filters.unpaid = stage === "unpaid";
        state.filters.notOrdered = stage === "notOrdered";
        state.filters.notReceived = stage === "notReceived";

        toggleChip(els.chipUnpaid, state.filters.unpaid);
        toggleChip(els.chipNotOrdered, state.filters.notOrdered);
        toggleChip(els.chipNotReceived, state.filters.notReceived);

        renderList();
        }

        els.chipUnpaid.addEventListener("click", ()=>{
        setStage(state.filters.unpaid ? null : "unpaid");
        });

        els.chipNotOrdered.addEventListener("click", ()=>{
        setStage(state.filters.notOrdered ? null : "notOrdered");
        });

        els.chipNotReceived.addEventListener("click", ()=>{
        setStage(state.filters.notReceived ? null : "notReceived");
        });


  els.q.addEventListener("input", ()=>{
    state.filters.q = els.q.value || "";
    renderList();
  });
    els.batchQ.addEventListener("input", ()=>{
    state.filters.batchNumber = (els.batchQ.value || "").trim();
    renderList();
  });

  els.refreshBtn.addEventListener("click", loadOrders);

  els.printBtn.addEventListener("click", ()=>{
    window.print();
  });
  // genBatchBtn listener
  els.createBatchBtn.addEventListener("click", async ()=>{
  const visible = getVisibleGroups();

  const order_ids = visible
    .filter(g => g.status?.paid === true && g.status?.ordered === false && !hasText(g.vendor_batch))
    .map(g => g.order_id);

  if (!order_ids.length){
    alert("No visible paid/not-ordered/unbatched orders to batch.");
    updateBatchButtons();
    return;
  }

  els.createBatchBtn.disabled = true;

    // get user token before calling the function
  const { data: { session } } = await supabase.auth.getSession();
  const token = session?.access_token;
  if (!token) {
    alert("Not authenticated — please sign in.");
    els.createBatchBtn.disabled = false;
    return;
  }

  const resp = await fetch(`${SUPABASE_URL}/functions/v1/create-vendor-batch`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${token}`,
    },
    body: JSON.stringify({ order_ids }),
  });

  if (!resp.ok){
    const t = await resp.text().catch(()=> "");
    alert("Batch create failed: " + t);
    await loadOrders();
    return;
  }

  const result = await resp.json(); // { ok:true, batch_id, items:[...] }

  // Reuse your existing "print rendering" code by using result.items / result.batch_id
  // (Keep your current render block here; it already works.)
  // ---- START: your existing print rendering block ----
  const w = window.open("", "_blank");
  const items = result.items || [];

  const byOrder = new Map();
  for (const r of items){
    if (!byOrder.has(r.order_id)) byOrder.set(r.order_id, []);
    byOrder.get(r.order_id).push(r);
  }

  const escape = (s)=> String(s ?? "").replace(/[&<>"']/g, (c)=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));

  const orderSections = Array.from(byOrder.entries()).map(function(entry){
    const oid = entry[0];
    const rows = entry[1];
    const lis = rows.map(function(r){
      var extraParts = [];
      if (r.custom_text) extraParts.push("Name: " + r.custom_text);
      if (r.jersey_number) extraParts.push("#" + r.jersey_number);
      var extra = extraParts.join(" - ");

      var li = "<li><b>" + escape(r.item) + "</b> - " + escape(r.size || "");
      if (extra) li += " <span class=\"muted\">(" + escape(extra) + ")</span>";
      li += "</li>";
      return li;
    }).join("");

    return "<div class=\"order\"><h2>Order " + escape(oid) + "</h2><ul>" + lis + "</ul></div>";
  }).join("");

  const batchId = escape(result.batch_id || "");
  var html =
    "<!doctype html><html><head><meta charset=\"utf-8\" />" +
    "<title>Vendor Batch " + batchId + "</title>" +
    "<style>" +
      "body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;padding:18px}" +
      "h1{margin:0 0 10px 0;font-size:20px}" +
      ".muted{color:#666;font-size:12px;margin-bottom:14px}" +
      ".order{margin:18px 0;page-break-inside:avoid}" +
      ".order h2{margin:0 0 8px 0;font-size:16px}" +
      "ul{margin:0;padding-left:18px}" +
      "li{margin:6px 0}" +
      "@media print{button{display:none}}" +
    "</style></head><body>" +
    "<h1>Vendor Batch " + batchId + "</h1>" +
    "<div class=\"muted\">Orders: " + order_ids.map(escape).join(", ") + "</div>" +
    "<button onclick=\"window.print()\">Print</button>" +
    orderSections +
    "</body></html>";

  w.document.open();
  w.document.write(html);
  w.document.close();
  w.focus();
  w.print();
  // ---- END: your existing print rendering block ----

  await loadOrders();
});

els.printBatchBtn.addEventListener("click", async ()=>{
  const visible = getVisibleGroups();

  // batches present in the visible list that are paid+ordered+have a batch id
  const batches = Array.from(new Set(
    visible
      .filter(g => g.status?.paid === true && g.status?.ordered === true && hasText(g.vendor_batch))
      .map(g => String(g.vendor_batch).trim())
  ));

  if (!batches.length){
    alert("No visible paid+ordered batches to print.");
    updateBatchButtons();
    return;
  }

  // open window synchronously to preserve user gesture
  const w = window.open("", "_blank");
  if (!w) {
    alert("Popup blocked. Please allow popups for this site and try again.");
    return;
  }

  // load all batch contents in parallel
  const fetches = batches.map(vb => printBatch(vb).catch(err=>{
    console.error("printBatch failed for", vb, err);
    return null;
  }));
  const results = await Promise.all(fetches);

  const escape = (s)=> String(s ?? "").replace(/[&<>"']/g, (c)=>({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));

  // build sections grouped by batch (single document, dividers between batches)
  const sections = [];
  for (let i=0;i<results.length;i++){
    const r = results[i];
    if (!r) continue;
    const items = r.items || [];

    // Group items by order_id for this batch
    const byOrder = new Map();
    for (const it of items){
      if (!byOrder.has(it.order_id)) byOrder.set(it.order_id, []);
      byOrder.get(it.order_id).push(it);
    }

        const orderHtml = Array.from(byOrder.entries()).map(([oid, rows])=>{
        const first = rows[0]; // group shares same parent_name
        const parentName = first.parent_name || "";

        const lis = rows.map(rr=>{
            const extra = [ rr.custom_text ? `Name: ${rr.custom_text}` : "", rr.jersey_number ? `#${rr.jersey_number}` : "" ].filter(Boolean).join(" • ");
            return `<li><b>${escape(rr.item)}</b> — ${escape(rr.size||"")}${extra ? ` <span class="muted">(${escape(extra)})</span>` : ""}</li>`;
        }).join("");

        return `
            <div class="order">
            <div style="margin-bottom:6px;">
                <span style="font-size:13px;font-weight:600;">${escape(parentName)}</span>
                <span style="color:#666;margin-left:8px;font-size:12px;">| Order ID - ${escape(oid)}</span>
            </div>
            <ul>${lis}</ul>
            </div>
        `;
        }).join("");



    sections.push(`
      <section class="batch-section">
        <h2 class="batch-title">Vendor Batch ${escape(r.batch_id || batches[i])}</h2>
        <div class="muted">Orders: ${Array.from(byOrder.keys()).map(escape).join(", ")}</div>
        ${orderHtml}
      </section>
    `);
  }

  const html = `<!doctype html>
  <html>
  <head>
    <meta charset="utf-8" />
    <title>Vendor Batches ${batches.map(escape).join(", ")}</title>
    <style>
      body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;padding:18px; color:#111}
      .batch-title{margin:0 0 6px 0; font-size:18px;}
      .muted{color:#666;font-size:12px;margin-bottom:10px;}
      .batch-section{margin:18px 0 24px 0; padding-bottom:12px; border-bottom:1px solid #ddd;}
      .order{margin:10px 0;}
      .order h3{margin:0 0 6px 0; font-size:14px;}
      ul{margin:6px 0 0 18px;}
      li{margin:6px 0; font-size:13px;}
      @media print{ button{display:none} }
    </style>
  </head>
  <body>
    <button onclick="window.print()">Print</button>
    ${sections.join("\n")}
  </body>
  </html>`;

  // write and print the single combined document
  w.document.open();
  w.document.write(html);
  w.document.close();
  w.focus();
  w.print();

  await loadOrders();
});




(async () => {
  const ok = await requireAdmin();
  if (!ok) return;

  // init chip visuals
  toggleChip(els.chipHideDelivered, true);

  // go
  loadOrders();
})();
</script>
</body>
</html>
